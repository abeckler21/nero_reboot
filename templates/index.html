<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NERO Dashboard</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

  <style>
    :root {
      --panel-padding: 20px;
    }

    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      background-color: #fafafa;
      margin: 0;
      padding: var(--panel-padding);
      height: 100vh;
      overflow: hidden;
      box-sizing: border-box;
      gap: var(--panel-padding);
    }

    .panel {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      padding: 10px;
      height: 100%;
      box-sizing: border-box;
      overflow: hidden;
    }

    h2 {
      margin: 8px 0;
      text-align: center;
    }

    /* give plotly containers explicit height */
    #aggregate-plot, #nero-plot, #pca {
      flex: 1;
      width: 100%;
      height: 500px;
      min-height: 400px;
    }

    #angle-slider {
      width: 80%;
      margin-top: 10px;
      align-self: center;
    }

    #angle-value {
      text-align: center;
      font-size: 14px;
      margin-top: 4px;
    }

    #original-canvas {
      align-self: center;
      border: 1px solid #ccc;
      border-radius: 6px;
      background: white;
      margin-bottom: 12px;
    }

    #legend {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      align-items: center;
      gap: 8px 12px;
      margin-top: 6px;
      padding: 5px 10px;
      border-top: 1px solid #ddd;
      font-size: 13px;
      overflow-y: auto;
      max-height: 70px;
    }

    @media (max-width: 1200px) {
      body {
        flex-direction: column;
        align-items: center;
        height: auto;
      }
      .panel {
        width: 95%;
        height: 80vh;
      }
    }

    /* loading message styling */
    #loading-msg {
      text-align: center;
      color: #666;
      margin-top: 8px;
    }
  </style>
</head>

<body>
  <!-- 1 Left: Aggregate NERO -->
  <div class="panel" id="aggregate-panel">
    <h2>Aggregate NERO</h2>
    <select id="label-select" style="margin:10px; padding:6px; font-size:14px;">
      <option value="All">All</option>
    </select>
    <div id="aggregate-plot"></div>
    <p id="loading-msg" style="display:none;">Computing aggregate NERO...</p>
  </div>

  <!-- 2 Middle: Individual NERO -->
  <div class="panel" id="nero-panel">
    <h2>Individual NERO</h2>
    <canvas id="original-canvas" width="120" height="120"></canvas>
    <div id="nero-plot" style="width:90%;max-width:480px;height:480px;align-self:center;"></div>
    <input type="range" id="angle-slider" min="0" max="360" value="0" step="1" disabled>
    <div id="angle-value">Angle: 0°</div>
  </div>

  <!-- 3 Right: PCA -->
  <div class="panel" id="pca-panel">
    <h2>PCA Embedding</h2>
    <div id="pca"></div>
    <div id="legend"></div>
  </div>

  <script>
    // ===== Load PCA data from Flask =====
    const data = {{ data | safe }};   // ensures read correctly

    // ===== Generate discrete color palette =====
    const uniqueLabels = [...new Set(data.map(d => d.label))].sort();
    const palette = [
      "#1f77b4","#ff7f0e","#2ca02c","#d62728","#9467bd","#8c564b",
      "#e377c2","#7f7f7f","#bcbd22","#17becf","#aec7e8","#ffbb78",
      "#98df8a","#ff9896","#c5b0d5","#c49c94","#f7b6d2","#c7c7c7",
      "#dbdb8d","#9edae5","#393b79","#637939","#8c6d31","#843c39",
      "#7b4173"
    ];

    const labelToColor = {};
    uniqueLabels.forEach((lbl, i) => labelToColor[lbl] = palette[i % palette.length]);
    const colors = data.map(d => labelToColor[d.label]);

    // ===== Configure PCA scatter tooltip =====
    const trace = {
      x: data.map(d => d.x),
      y: data.map(d => d.y),
      mode: 'markers',
      type: 'scatter',
      text: data.map(d => `Sample ${d.idx}<br>Label ${d.label}`),
      hoverinfo: 'text',
      marker: { color: colors, size: 7, line: { width: 0.5, color: '#333' } }
    };
    const layout = {
      title: { text: 'Feature PCA (Click to view NERO)', font: { size: 18 } },
      hovermode: 'closest',
      xaxis: { title: 'PCA 1' },
      yaxis: { title: 'PCA 2' },
      margin: { l: 60, r: 60, t: 40, b: 60 },
      plot_bgcolor: '#fff',
      paper_bgcolor: '#fff',
      showlegend: false,
    };
    Plotly.newPlot('pca', [trace], layout, {responsive: true, displaylogo: false});

    // ===== Build legend =====
    const legendDiv = document.getElementById("legend");
    uniqueLabels.forEach(lbl => {
      const item = document.createElement("div");
      item.className = "legend-item";
      const colorBox = document.createElement("div");
      colorBox.className = "legend-color";
      colorBox.style.backgroundColor = labelToColor[lbl];
      const labelText = document.createElement("span");
      labelText.textContent = lbl;
      item.appendChild(colorBox);
      item.appendChild(labelText);
      legendDiv.appendChild(item);
    });

    // ===== Handle Aggregate NERO dropdown =====
    const labelSelect = document.getElementById("label-select");
    const aggregateDiv = document.getElementById("aggregate-plot");
    const loadingMsg = document.getElementById("loading-msg");

    // Build label list (A–Y excluding J, Z)
    const letters = [];
    for (let c = 65; c <= 90; c++) if (c !== 74 && c !== 90) letters.push(String.fromCharCode(c));
    letters.forEach(l => {
      const opt = document.createElement("option");
      opt.value = l;
      opt.textContent = l;
      labelSelect.appendChild(opt);
    });

    //  fixed version: don't overwrite aggregate-plot div
    function loadAggregate(label) {
      loadingMsg.style.display = "block";
      aggregateDiv.innerHTML = "";
      console.log("Requesting aggregate NERO for:", label);

      fetch("/get_aggregate_nero", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ label })
      })
      .then(res => res.json())
      .then(json => {
        loadingMsg.style.display = "none";
        if (!json.nero_plot) {
          aggregateDiv.innerHTML = "<p>No data available.</p>";
          return;
        }
        const fig = JSON.parse(json.nero_plot);
        console.log("Loaded aggregate NERO plot:", fig);
        Plotly.newPlot("aggregate-plot", fig.data, fig.layout, {responsive: true, displaylogo: false});
      })
      .catch(err => {
        console.error("Error fetching aggregate NERO:", err);
        loadingMsg.style.display = "none";
        aggregateDiv.innerHTML = "<p>Error computing NERO.</p>";
      });
    }

    // Helper: map letters to numeric labels (A..Y skipping J,Z)
    const LETTERS = [];
    for (let c = 65; c <= 90; c++) if (c !== 74 && c !== 90) LETTERS.push(String.fromCharCode(c));
    const VALID_LABELS = LETTERS.map((_, i) => (i < 9 ? i : i + 1));            // 0..8,10..24
    const LABEL_NUM_BY_LETTER = Object.fromEntries(LETTERS.map((l, i) => [l, VALID_LABELS[i]]));

    // Helper: convert hex (#RRGGBB) to rgba(r,g,b,a)
    function hexToRgba(hex, alpha) {
      const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      if (!m) return `rgba(0,0,0,${alpha})`;
      const r = parseInt(m[1], 16), g = parseInt(m[2], 16), b = parseInt(m[3], 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }

    // Keep your existing loadAggregate call
    loadAggregate("All");

    // Replace your dropdown listener with this:
    labelSelect.addEventListener("change", e => {
      const selected = e.target.value;
      loadAggregate(selected); // left panel stays the same

      // Figure out which numeric label is "selected"
      let selectedLabelNum = null;
      if (selected !== "All") {
        selectedLabelNum = LABEL_NUM_BY_LETTER[selected];
      }

      // Build per-point colors and sizes with alpha adjustment
      const colorArr = [];
      const sizeArr  = [];
      for (const d of data) {
        const baseHex = labelToColor[d.label] || "#7f7f7f";
        const isSelected = (selected === "All") || (d.label === selectedLabelNum);
        const alpha = isSelected ? 1.0 : 0.1;       // <- fade non-selected to 0.1
        const size  = isSelected ? 8 : 5;           // optional emphasis
        colorArr.push(hexToRgba(baseHex, alpha));
        sizeArr.push(size);
      }

      // Update the existing PCA trace in place (trace index 0)
      Plotly.restyle('pca', {
        'marker.color': [colorArr],
        'marker.size':  [sizeArr]
      }, [0]);
    });


    // ===== Individual NERO + rotation =====
    document.getElementById('pca').on('plotly_click', function(event) {
      const idx = event.points[0].pointIndex;
      const canvas = document.getElementById('original-canvas');
      const ctx = canvas.getContext('2d');
      const neroDiv = document.getElementById('nero-plot');
      const slider = document.getElementById('angle-slider');
      const angleValue = document.getElementById('angle-value');

      neroDiv.innerHTML = "<p>Generating NERO plot...</p>";
      slider.disabled = true;
      angleValue.textContent = "Angle: ...";
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      fetch('/get_nero', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ index: idx })
      })
      .then(res => res.json())
      .then(json => {
        const img = new Image();
        img.src = "data:image/png;base64," + json.original_image;
        img.onload = () => {
          const drawRotated = angleDeg => {
            const angleRad = angleDeg * Math.PI / 180;
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.translate(cx, cy);
            ctx.rotate(angleRad);
            ctx.scale(scale, scale);
            ctx.drawImage(img, -img.width / 2, -img.height / 2);
            ctx.restore();
          };
          drawRotated(0);

          const fig = JSON.parse(json.nero_plot);
          Plotly.newPlot('nero-plot', fig.data, fig.layout, {responsive: true, displaylogo: false});

          slider.disabled = false;
          slider.value = 0;
          angleValue.textContent = "Angle: 0°";
          slider.oninput = function() {
            const angle = parseFloat(this.value);
            angleValue.textContent = `Angle: ${angle}°`;
            Plotly.restyle('nero-plot', { 'r': [[0,1]], 'theta': [[angle,angle]] }, [1]);
            drawRotated(angle);
          };
        };
      })
      .catch(err => {
        console.error("Error fetching NERO data:", err);
        neroDiv.innerHTML = "<p>Error generating NERO plot.</p>";
      });
    });
  </script>
</body>
</html>
